For our final project for CS223, we (Anna Zipp and Krish Suchak) decided to make a web page that converts user-provided images to ASCII art. First, we created a button that asks the user for a file (using the File library). Once a user asks for a file, then we store it in our model in the form of Bytes. We also take the file and read it into a 2-dimensional list of Colors or pixels (using the elm-image library). Unfortunately, this image library only works with PNGs and BMPs, so we restrict use of our app to PNGs only (as that is what we used in testing). Next, we take the 2d list of Colors and convert the RGB values of each pixel to a float representing the luminance or brightness of the pixel using the formula Y=0.2126R + 0.7152G + 0.0722B as specified here: https://en.wikipedia.org/wiki/Relative_luminance. This weighted average produces a float standardized on the interval [0, 1] representing the brightness of a pixel based on the human eye’s perception of colors. Then, we made a function to convert the standardized float to an appropriate ASCII character (a period would represent a very bright character as it possesses a relatively high level of whitespace while a dollar sign represents a quite dark character for the opposite reason). After creating this function, we map it to our 2d list of floats and create a 2d array of characters. Note: we skip certain rows and columns to produce an image with an ostensibly correct aspect ratio since most monospaced fonts do not have equal height and width intra-character simply inter-character. Finally, we join the character arrays and produce a list of strings. Each string is converted to a div with certain css styling (fixed font size and font family set to monospace), and the list of divs is passed to the view function.

The main takeaways from this project are the use of the model, view, update architecture recommended when creating Elm apps. We used to model to store the image and associated ASCII art. We used the update function to load the user-selected file into the model. We used the view function to display our converted ASCII text to the user. We also used lists and arrays and learned the importance of each. When we wanted to access specific indices of a data structure (like mapping brightness to an ASCII character), we used arrays for O(1) lookup time as opposed to O(n) time. For example, we didn’t iterate through every ASCII character in our brightness to ASCII lookup table (which was actually an array of Char) to figure out which one best matched a luminance / brightness float. We simply calculated the index of the corresponding ASCII character and retrieved it immediately. Similarly when we skip rows to display for the sake of maintaining image aspect ratio, we do not bother to convert them from pixel information to brightness floats (due to the potential for wasted operations). We ended up implementing everything recommended from the first round of feedback. Given more time, we would implement auto-resize and increase the default font size to give more of an ASCII art “feel” rather than the pointillism we have achieved. The implementation of auto-resize (character augmentation or reduction per row) would be to reduce the risk of side-effects like text wrapping over to the next row in weird ways. Ideally, we would also allow the user to pick which ASCII lookup table they want to use themselves. Right now, we enforce this array: [ '░', '▒', '▓', '█' ] but the commented out code also includes a more stereotypical character set:  [ '.', ':', '-', '=', '+', '*', '#', '%', '@' ] .
